import re
import os
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from datetime import datetime, timedelta
from database.models import User, Transaction, TransactionType
from database.session import Session
from database.db_operations import (
    get_user,
    add_transaction,
    get_user_transactions,
    update_user_settings
)
from services.statement_parser import statement_parser, receipt_processor
from services.ml_categorizer import transaction_categorizer
from services.openai_service import openai_service
from services.analytics_service import analytics_service

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logger = logging.getLogger(__name__)

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å"""
    try:
        user = get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ—é /start")
            return
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —Ü–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è —É —Ñ–æ—Ä–º–∞—Ç—ñ "—Å—É–º–∞ –æ–ø–∏—Å"
        match = re.match(r'^(\d+(?:\.\d+)?)\s+(.+)$', update.message.text)
        if match:
            amount = float(match.group(1))
            description = match.group(2)
            
            transaction = Transaction(
                user_id=user.id,
                amount=amount,
                type=TransactionType.EXPENSE,
                description=description
            )
            
            add_transaction(transaction)
            
            await update.message.reply_text(
                f"‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é –¥–æ–¥–∞–Ω–æ!\n"
                f"–°—É–º–∞: {amount} –≥—Ä–Ω\n"
                f"–û–ø–∏—Å: {description}"
            )
            return
        
        # –Ø–∫—â–æ —Ü–µ –Ω–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—è, –≤—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø—ñ–¥–∫–∞–∑–∫—É
        await update.message.reply_text(
            "üìù –©–æ–± –¥–æ–¥–∞—Ç–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é, –Ω–∞–ø–∏—à—ñ—Ç—å —Å—É–º—É —Ç–∞ –æ–ø–∏—Å.\n"
            "–ù–∞–ø—Ä–∏–∫–ª–∞–¥: 100 –ü—Ä–æ–¥—É–∫—Ç–∏\n\n"
            "–ê–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /add"
        )
    except Exception as e:
        logger.error(f"Error handling text message: {str(e)}")
        await update.message.reply_text("–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è.")

async def handle_financial_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ —Ñ—ñ–Ω–∞–Ω—Å–æ–≤–æ–≥–æ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º OpenAI"""
    question = update.message.text.strip()
    
    thinking_message = await update.message.reply_text(
        "ü§î –û–±–¥—É–º—É—é –≤—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞ –≤–∞—à–µ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è..."
    )
    
    try:
        from database.db_operations import get_or_create_user
        from services.financial_advisor import answer_user_question
        
        # –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        telegram_id = update.effective_user.id
        user = get_or_create_user(
            telegram_id=telegram_id, 
            username=update.effective_user.username,
            first_name=update.effective_user.first_name,
            last_name=update.effective_user.last_name
        )
        
        # –û—Ç—Ä–∏–º—É—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è
        answer = answer_user_question(user.id, question)
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å
        await thinking_message.edit_text(
            f"üí° –í—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞ –≤–∞—à–µ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è:\n\n{answer}"
        )
    except Exception as e:
        await thinking_message.edit_text(
            f"‚ùå –ù–∞ –∂–∞–ª—å, —Å—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤–∞—à–æ–≥–æ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è: {str(e)}\n"
            "–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª—é–≤–∞—Ç–∏ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è –∞–±–æ –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –∫–æ–º–∞–Ω–¥–∏ –ø—ñ–¥—Ç—Ä–∏–º–∫–∏."
        )

async def handle_advice_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–ª—è—î –∑–∞–ø–∏—Ç–∏ –Ω–∞ —Ñ—ñ–Ω–∞–Ω—Å–æ–≤—É –ø–æ—Ä–∞–¥—É"""
    await update.message.reply_text("ü§î –ê–Ω–∞–ª—ñ–∑—É—é –≤–∞—à—ñ —Ñ—ñ–Ω–∞–Ω—Å–æ–≤—ñ –¥–∞–Ω—ñ –¥–ª—è –Ω–∞–¥–∞–Ω–Ω—è –ø–æ—Ä–∞–¥–∏...")
    
    try:
        from database.db_operations import get_or_create_user
        from services.financial_advisor import FinancialAdvisor
        
        # –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        telegram_id = update.effective_user.id
        user = get_or_create_user(
            telegram_id=telegram_id, 
            username=update.effective_user.username,
            first_name=update.effective_user.first_name,
            last_name=update.effective_user.last_name
        )
        
        # –°—Ç–≤–æ—Ä—é—î–º–æ –æ–±'—î–∫—Ç —Ñ—ñ–Ω–∞–Ω—Å–æ–≤–æ–≥–æ —Ä–∞–¥–Ω–∏–∫–∞
        advisor = FinancialAdvisor(user.id)
        
        # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø –ø–æ—Ä–∞–¥–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ç–µ–∫—Å—Ç—É –∑–∞–ø–∏—Ç—É
        text = update.message.text.lower()
        
        if any(keyword in text for keyword in ['–∑–∞–æ—â–∞–¥–∏—Ç–∏', '–∑–∞–æ—â–∞–¥–∂–µ–Ω–Ω—è', '–µ–∫–æ–Ω–æ–º–∏—Ç–∏', '–µ–∫–æ–Ω–æ–º—ñ—è']):
            advice_type = 'savings'
        elif any(keyword in text for keyword in ['—ñ–Ω–≤–µ—Å—Ç–∏—Ü—ñ—ó', '—ñ–Ω–≤–µ—Å—Ç—É–≤–∞—Ç–∏', '–≤–∫–ª–∞–¥–∞—Ç–∏', '–≤–∫–ª–∞–¥–µ–Ω–Ω—è']):
            advice_type = 'investment'
        elif any(keyword in text for keyword in ['–±—é–¥–∂–µ—Ç', '–ø–ª–∞–Ω—É–≤–∞—Ç–∏', '–≤–∏—Ç—Ä–∞—Ç–∏', '–≤–∏—Ç—Ä–∞—á–∞—Ç–∏']):
            advice_type = 'budget'
        else:
            advice_type = 'general'
        
        # –ì–µ–Ω–µ—Ä—É—î–º–æ –ø–æ—Ä–∞–¥—É
        advice = advisor.generate_financial_advice(advice_type)
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–æ—Ä–∞–¥—É
        await update.message.reply_text(
            f"üí° –§—ñ–Ω–∞–Ω—Å–æ–≤–∞ –ø–æ—Ä–∞–¥–∞:\n\n{advice}"
        )
    except Exception as e:
        await update.message.reply_text(
            f"‚ùå –ù–∞ –∂–∞–ª—å, —Å—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –ø–æ—Ä–∞–¥–∏: {str(e)}\n"
            "–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ –∞–±–æ –∑–≤–µ—Ä–Ω—ñ—Ç—å—Å—è –¥–æ –∫–æ–º–∞–Ω–¥–∏ /help."
        )

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ—ñ–π —á–µ–∫—ñ–≤"""
    try:
        user = get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ—é /start")
            return
        
        # –û—Ç—Ä–∏–º—É—î–º–æ —Ñ–æ—Ç–æ
        photo = update.message.photo[-1]
        file = await context.bot.get_file(photo.file_id)
        
        # –°—Ç–≤–æ—Ä—é—î–º–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—é –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è, —è–∫—â–æ —ó—ó –Ω–µ–º–∞—î
        os.makedirs('uploads', exist_ok=True)
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–æ—Ç–æ
        file_path = f'uploads/receipt_{user.id}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.jpg'
        await file.download_to_drive(file_path)
        
        # –û–±—Ä–æ–±–ª—è—î–º–æ —á–µ–∫
        receipt_data = receipt_processor.process_receipt_image(file_path)
        
        # –ö–∞—Ç–µ–≥–æ—Ä—ñ–∑—É—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é
        category, confidence = transaction_categorizer.predict_category(receipt_data['raw_text'])
        
        # –î–æ–¥–∞—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é
        transaction = {
            'user_id': user.id,
            'amount': receipt_data['total_amount'],
            'description': 'Receipt scan',
            'category': category,
            'type': 'expense',
            'date': receipt_data['date'],
            'source': 'receipt',
            'receipt_image': file_path
        }
        
        add_transaction(transaction)
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è
        await update.message.reply_text(
            f"–ß–µ–∫ –æ–±—Ä–æ–±–ª–µ–Ω–æ!\n"
            f"–°—É–º–∞: {receipt_data['total_amount']}\n"
            f"–î–∞—Ç–∞: {receipt_data['date'].strftime('%Y-%m-%d')}\n"
            f"–ö–∞—Ç–µ–≥–æ—Ä—ñ—è: {category} (–≤–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å: {confidence:.2%})"
        )
    except Exception as e:
        logger.error(f"Error handling photo: {str(e)}")
        await update.message.reply_text("–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ —á–µ–∫–∞.")

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ –±–∞–Ω–∫—ñ–≤—Å—å–∫–∏—Ö –≤–∏–ø–∏—Å–æ–∫"""
    try:
        user = get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ—é /start")
            return
        
        # –û—Ç—Ä–∏–º—É—î–º–æ –¥–æ–∫—É–º–µ–Ω—Ç
        document = update.message.document
        file = await context.bot.get_file(document.file_id)
        
        # –°—Ç–≤–æ—Ä—é—î–º–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—é –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è, —è–∫—â–æ —ó—ó –Ω–µ–º–∞—î
        os.makedirs('uploads', exist_ok=True)
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª
        file_path = f'uploads/statement_{user.id}_{datetime.now().strftime("%Y%m%d_%H%M%S")}{os.path.splitext(document.file_name)[1]}'
        await file.download_to_drive(file_path)
        
        # –û–±—Ä–æ–±–ª—è—î–º–æ –≤–∏–ø–∏—Å–∫—É
        transactions = statement_parser.parse_bank_statement(file_path)
        
        # –î–æ–¥–∞—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
        added_count = 0
        for transaction in transactions:
            # –ö–∞—Ç–µ–≥–æ—Ä—ñ–∑—É—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é
            category, confidence = transaction_categorizer.predict_category(transaction['description'])
            
            transaction_data = {
                'user_id': user.id,
                'amount': transaction['amount'],
                'description': transaction['description'],
                'category': category,
                'type': transaction['type'],
                'date': transaction['date'],
                'source': 'bank_statement'
            }
            
            add_transaction(transaction_data)
            added_count += 1
        
        await update.message.reply_text(
            f"–í–∏–ø–∏—Å–∫—É –æ–±—Ä–æ–±–ª–µ–Ω–æ!\n"
            f"–î–æ–¥–∞–Ω–æ {added_count} —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π."
        )
    except Exception as e:
        logger.error(f"Error handling document: {str(e)}")
        await update.message.reply_text("–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –≤–∏–ø–∏—Å–∫–∏.")

async def handle_report_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ –∫–æ–º–∞–Ω–¥–∏ /report"""
    try:
        user = get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ—é /start")
            return
        
        # –û—Ç—Ä–∏–º—É—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ–π –º—ñ—Å—è—Ü—å
        end_date = datetime.now()
        start_date = end_date - timedelta(days=30)
        transactions = get_user_transactions(user.id, start_date, end_date)
        
        # –ì–µ–Ω–µ—Ä—É—î–º–æ –∑–≤—ñ—Ç
        report = analytics_service.generate_monthly_report(transactions)
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø—ñ–¥—Å—É–º–æ–∫
        summary = report['summary']
        await update.message.reply_text(
            f"üìä –ú—ñ—Å—è—á–Ω–∏–π –∑–≤—ñ—Ç\n\n"
            f"–î–æ—Ö–æ–¥–∏: {summary['total_income']:.2f}\n"
            f"–í–∏—Ç—Ä–∞—Ç–∏: {summary['total_expenses']:.2f}\n"
            f"–ó–∞–æ—â–∞–¥–∂–µ–Ω–Ω—è: {summary['net_savings']:.2f}\n"
            f"–ù–æ—Ä–º–∞ –∑–∞–æ—â–∞–¥–∂–µ–Ω–Ω—è: {summary['savings_rate']:.1f}%"
        )
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –≥—Ä–∞—Ñ—ñ–∫–∏
        for viz_type, viz_data in report['visualizations'].items():
            if viz_data:  # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –¥–∞–Ω—ñ –¥–ª—è –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—ó
                await update.message.reply_photo(
                    photo=viz_data,
                    caption=f"–ì—Ä–∞—Ñ—ñ–∫: {viz_type}"
                )
    except Exception as e:
        logger.error(f"Error generating report: {str(e)}")
        await update.message.reply_text("–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –∑–≤—ñ—Ç—É.")

async def handle_advice_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ –∫–æ–º–∞–Ω–¥–∏ /advice"""
    try:
        user = get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ—é /start")
            return
        
        # –û—Ç—Ä–∏–º—É—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –∑–∞ –æ—Å—Ç–∞–Ω–Ω—ñ 3 –º—ñ—Å—è—Ü—ñ
        end_date = datetime.now()
        start_date = end_date - timedelta(days=90)
        transactions = get_user_transactions(user.id, start_date, end_date)
        
        # –ì–µ–Ω–µ—Ä—É—î–º–æ –ø–æ—Ä–∞–¥–∏
        advice = openai_service.generate_financial_advice(transactions)
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–æ—Ä–∞–¥–∏
        await update.message.reply_text(
            f"üí° –§—ñ–Ω–∞–Ω—Å–æ–≤—ñ –ø–æ—Ä–∞–¥–∏\n\n"
            f"–ê–Ω–∞–ª—ñ–∑ —Å–∏—Ç—É–∞—Ü—ñ—ó:\n{advice['analysis']}\n\n"
            f"–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó:\n" + "\n".join(f"‚Ä¢ {rec}" for rec in advice['recommendations']) + "\n\n"
            f"–û–±–ª–∞—Å—Ç—ñ –¥–ª—è –ø–æ–∫—Ä–∞—â–µ–Ω–Ω—è:\n" + "\n".join(f"‚Ä¢ {area}" for area in advice['improvement_areas'])
        )
        
        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–ª–∞–Ω–∏
        await update.message.reply_text(
            f"üìÖ –ü–ª–∞–Ω–∏\n\n"
            f"–ö–æ—Ä–æ—Ç–∫–æ—Å—Ç—Ä–æ–∫–æ–≤–∏–π –ø–ª–∞–Ω:\n{advice['short_term_plan']}\n\n"
            f"–î–æ–≤–≥–æ—Å—Ç—Ä–æ–∫–æ–≤–∏–π –ø–ª–∞–Ω:\n{advice['long_term_plan']}"
        )
    except Exception as e:
        logger.error(f"Error generating advice: {str(e)}")
        await update.message.reply_text("–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó –ø–æ—Ä–∞–¥.")

async def handle_analyze_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–æ–±–∫–∞ –∫–æ–º–∞–Ω–¥–∏ /analyze"""
    try:
        user = get_user(update.effective_user.id)
        if not user:
            await update.message.reply_text("–ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø–æ—á–∞—Ç–∫—É –Ω–∞–ª–∞—à—Ç—É–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ—é /start")
            return
        
        # –°—Ç–≤–æ—Ä—é—î–º–æ –∫–ª–∞–≤—ñ–∞—Ç—É—Ä—É –¥–ª—è –≤–∏–±–æ—Ä—É —Ç–∏–ø—É –∞–Ω–∞–ª—ñ–∑—É
        keyboard = [
            [
                InlineKeyboardButton("–ê–Ω–∞–ª—ñ–∑ –∫–∞—Ç–µ–≥–æ—Ä—ñ–π", callback_data="analyze_categories"),
                InlineKeyboardButton("–¢—Ä–µ–Ω–¥–∏ –≤–∏—Ç—Ä–∞—Ç", callback_data="analyze_trends")
            ],
            [
                InlineKeyboardButton("–ê–Ω–∞–ª—ñ–∑ –±—é–¥–∂–µ—Ç—É", callback_data="analyze_budget"),
                InlineKeyboardButton("–ü–æ–≤–Ω–∏–π –∞–Ω–∞–ª—ñ–∑", callback_data="analyze_full")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "–í–∏–±–µ—Ä—ñ—Ç—å —Ç–∏–ø –∞–Ω–∞–ª—ñ–∑—É:",
            reply_markup=reply_markup
        )
    except Exception as e:
        logger.error(f"Error handling analyze command: {str(e)}")
        await update.message.reply_text("–í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ –∫–æ–º–∞–Ω–¥–∏ –∞–Ω–∞–ª—ñ–∑—É.")